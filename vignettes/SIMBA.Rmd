---
title: "SIMBA: name"
author:
- name: Simone Tiberi
  affiliation:
  - Department of Statistical Sciences, University of Bologna, Bologna, Italy
  email: simone.tiberi@unibo.it
- name: Jordy Bollon
  affiliation: 
  - Computational Department of CMP3VDA, Aosta, Italy
  email: jordy.bollon@iit.it
package: "`r BiocStyle::pkg_ver('SIMBA')`"
date: "`r format(Sys.Date(), '%m/%d/%Y')`"
bibliography: References.bib
vignette: >
  %\VignetteIndexEntry{SIMBA}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
output: 
  BiocStyle::html_document
---

---
```{r setup, echo=FALSE, results="hide"}
knitr::opts_chunk$set(tidy=FALSE, cache=TRUE,
                      dev="png",
                      message=TRUE, error=FALSE, warning=TRUE)
```

# Introduction
*SIMBA* is a Bayesian method to perform inference on single protein isoforms.
Our approach infers the presence/absence of protein isoforms, and also estimates their abundance;
additionally, it provides a measure of the uncertainty of these estimates, via:
i) the posterior probability the a protein isoform is present in the sample;
ii) a posterior credible interval of its abundance.
SIMBA inputs liquid cromatography mass spectrometry (MS) data, and can work with both PSM counts, and intensities.
When available, trascript isoform abundances (i.e., TPMs) are also incorporated:
TPMs are used to formulate an informative prior for the respective protein isoform relative abundance.
We further identify isoforms where the relative abundance of proteins and transcripts significantly differ.
We use a two-layer latent variable approach to model two sources of uncertainty typical of MS data:
i) peptides may be erroneously detected (even when absent);
ii) many peptides are compatible with multiple protein isoforms.
In the first layer, we sample the presence/absence of each peptide based on its estimated probability 
of being mistakenly detected, also known as PEP.
In the second layer, for peptides that were estimated as being present, 
we allocate their abundance across the protein isoforms they map to.
These two steps allow us to recover the presence and abundance of each protein isoform.

## Bioconductor installation
`SIMBA` is available on [Bioconductor](https://bioconductor.org/packages/SIMBA) and can be installed with the command:
```{r Bioconductor_installation, eval=FALSE}
if (!requireNamespace("BiocManager", quietly=TRUE))
  install.packages("BiocManager")
BiocManager::install("SIMBA")
```

To access the R code used in the vignettes, type:
```{r vignettes, eval=FALSE} 
browseVignettes("SIMBA")
```

# Questions, issues and citation
Questions relative to *SIMBA* should be reported as a new issue at *[BugReports](https://github.com/SimoneTiberi/SIMBA/issues)*.

To cite *SIMBA*, type:
```{r citation} 
citation("SIMBA")
```

# Load the package
Load *SIMBA*.
```{r load, message=FALSE}
library(SIMBA)
```

# Input data
The input data of SIMBA must be loaded and preprocessed by using the `load_data` function. The data to be imputed can be generated by *MetaMorpheus* (MM) [@MetaMorpheus], *OpenMS* Toolkit [@OpenMS] or other tools if the data to be imputed is structured as described in the section [From user data](#from-user-data). Here, we use a small dataset created by MetaMorpheus.

The scripts to generate this dataset can be found [link a inst/script].

We start by setting the directory of the data (internal in the package):
```{r specify extdata path}
data_dir = system.file("extdata", package = "SIMBA")
```

## From MetaMorpheus Tool
We define the path to the AllPeptides.psmtsv file returned by MetaMorpheus:
```{r set path MM psm}
path_to_peptides_psm = paste0(data_dir, "/AllPeptides.psmtsv")
```

### PSM counts
The AllPeptides.psmtsv file contains all the information required to run `SIMBA` with PSM counts. To load the file run:
```{r load psm}
data_loaded = load_data(path_to_peptides_psm = path_to_peptides_psm)
```

### Intensities
If we want to run the algorithm with peptides intensities, in addition to "AllPeptides.psmtsv", we need to load a second file generated by MM: "AllQuantifiedPeptides.tsv".
Then, we have to set `abundance_type` equal to "intensities" (otherwise by default the \code{load_data} function will preprocess psm counts).
```{r set path MM intensities}
path_to_peptides_psm = paste0(data_dir, "/AllPeptides.psmtsv")
path_to_peptides_intensities = paste0(data_dir, "/AllQuantifiedPeptides.tsv")
data_loaded = load_data(path_to_peptides_psm = path_to_peptides_psm,
                        path_to_peptides_intensities = path_to_peptides_intensities,
                        abundance_type = "intensities")
```

## From OpenMS Toolkit
SIMBA is compatible with the PSM file (idXML format) produced by OpenMS toolkit. The pipeline to create an idXML file with psm data via OpenMS toolkit is available at the following (dove lo aggiungo il file con la pipeline?). Once the file is created, we just need to specify the file path and set `input_type` equal to "openMS".
```{r set path OpenMS}
# NOT RUN
#data_loaded = load_data(path_to_peptides_psm = "/path/to/file.idXML",
#                        input_type = "openMS")
```
Note that with OpenMS data the algorithm processes psm counts (not intensities) and the FDR_thd option is ignored (see section FDR). FDR filtering is performed during the data generation (see link pipeline sopracitata).

## From user data
We can also input data coming from any bioinformatics tool. To this aim, the data must be structured in a tsv file where each raw corresponds to a identified peptide with 4 fields:

* 'Y': a numeric variable indicating the peptide abundance;
* 'EC': Equivalent Classes, a character string indicating the isoform(s) name the peptide maps to. If the peptide maps to multiple protein isoforms, the names must be separated with "|", i.e. "name_isoform_1|name_isoform_2";
* 'PEP': (optional) a numeric variable indicating the Peptide Error Probability;
* 'sequence': (required with PEP) a character string indicating the peptide name/id/amino acids sequence in order to identify identical peptides with different/similar PEP values.

Note that with user data the following options are ignored: `abundance_type`, `FDR_thd` (the file should already be filtered) and `path_to_peptides_intensities`.

To load the tsv file with user data, we just need to specify the file path and set `input_type` equal to "other".
```{r set path user}
# NOT RUN
#data_loaded = load_data(path_to_peptides_psm = "/path/to/user_data.tsv",
#                        input_type = "other")
```

## mRNA data integration
When available, trascript isoform abundances (TPMs) can be incorporated to enhance protein isoform inference. To load TPMs data we have to specify the path to the TPMs file. The format file must be a tsv with two fields for each isoform:

* 'isoname': a character string indicating the isoform name;
* 'tpm': a numeric variable indicating the transcripts per million.

```{r set path mRNA}
tpm_path = paste0(data_dir, "/jurkat_isoform_kallisto.tsv")
data_loaded = load_data(path_to_peptides_psm = path_to_peptides_psm,
                        path_to_tpm = tpm_path)
```

## FDR threshold
For data generated by MM, we can set the FDR threshold to filter out unreliable peptides. By default the `FDR_thd` option is set to 0.01.

## PEP option
If the Peptide Error Probability is provided, we can enable the `PEP` option to add a layer to the Bayesian variable latent model. With this additional layer the algorithm sample the presence/absence of each peptide based on its PEP.
```{r with PEP}
# NOT RUN
# data_loaded_pep = load_data(path_to_peptides_psm = path_to_peptides_psm,
#                             PEP = TRUE)
```

# Run SIMBA algorithm
Once we have imputed the data, we can run the algorithm using the `inference` function:
```{r inference}
# NOT RUN
# results = inference(data_loaded)
```

## Gene Normalization
In order to output the protein isoforms results normalized by gene, we need to provide a csv file with two fields indicating the isoform and the gene name.
```{r default inference}
path_to_map_iso_gene = paste0(data_dir, "/map_iso_gene.csv")
t_start = Sys.time()
results = inference(data_loaded, map_iso_gene = path_to_map_iso_gene)
t_end = Sys.time()
default_time = t_end - t_start
```

## Setting the prior
The transcriptomics data contribute to formulate an informative prior for the protein isoform relative abundances. The final results will be a trade-off between proteomics and transcriptomics information. We can regulate this trade-off by setting a prior coefficient on the tpm data. By default, the model set the prior equal to 0.1. This means that the concentration parameters of the Dirichelet distribution, from which we sample the PIs relative abundances, consist of absolute protein abundance and tpm multiplied by 10% of the total protein abundance. A prior equal to zero is equivalent to run the model without transcriptomics data integration, while larger values force the inference process to be driven only by the mRNA information without considering the proteomics input.

Here, we run the model with prior equal to zero (ignoring mRNA data):
```{r no prior inference}
# NOT RUN
# results_no_prior = inference(data_loaded, prior = 0, map_iso_gene = path_to_map_iso_gene)
```

## Parallel computation
By default the `inference` function execute the algorithm with one single core. We can enable the parallel computation by setting to TRUE the `parallel` argument and increase the number of cores in order to speed up the execution time:
```{r no parallel inference}
t_start = Sys.time()
results_parallel = inference(data_loaded, parallel = TRUE, map_iso_gene = path_to_map_iso_gene, n_cores = 8)
t_end = Sys.time()
parallel_time = t_end - t_start

# Single core VS parallel computation (two cores):
parallel_time - default_time
```
Sottolineare che il guadagno di tempo è trascurabile in quanto il dataset è piccolo?

# Plotting the results
Finally, SIMBA provides the `plot_relative_abundances` function to visualize differential relative abundances between transcriptomics and
proteomics isoforms within a specific gene:
```{r plotting results}
plot_relative_abundances(results, gene_id = "HLA")
```
By default `plot_relative_abundances` normalize the relative abundances. To disable the normalization, we just need to set to FALSE the
`normalize_gene` argument.
```{r plotting results no normalization}
plot_relative_abundances(results, gene_id = "HLA", normalize_gene = F)
```
Note that `plot_relative_abundances` works because, when we have executed the `inference` function, we have passed a csv file that maps all the protein isoforms to the corresponding gene.

# Session info
```{r sessionInfo}
sessionInfo()
```

# References