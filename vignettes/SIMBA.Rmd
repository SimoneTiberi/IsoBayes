---
title: "SIMBA: name"
author:
- name: Simone Tiberi
  affiliation:
  - Department of Statistical Sciences, University of Bologna, Bologna, Italy
  email: simone.tiberi@unibo.it
- name: Jordy Bollon
  affiliation: 
  - Computational Department of CMP3VDA, Aosta, Italy
  email: jordy.bollon@iit.it
package: "`r BiocStyle::pkg_ver('SIMBA')`"
date: "`r format(Sys.Date(), '%m/%d/%Y')`"
bibliography: References.bib
vignette: >
  %\VignetteIndexEntry{SIMBA}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
output: 
  BiocStyle::html_document
---

---
```{r setup, echo=FALSE, results="hide"}
knitr::opts_chunk$set(tidy=FALSE, cache=TRUE,
                      dev="png",
                      message=TRUE, error=FALSE, warning=TRUE)
```

# Introduction
*SIMBA* is a Bayesian method to perform inference on single protein isoforms.
Our approach infers the presence/absence of protein isoforms, and also estimates their abundance;
additionally, it provides a measure of the uncertainty of these estimates, via:
i) the posterior probability the a protein isoform is present in the sample;
ii) a posterior credible interval of its abundance.
*SIMBA* inputs liquid cromatography mass spectrometry (MS) data, and can work with both PSM counts, and intensities.
When available, trascript isoform abundances (i.e., TPMs) are also incorporated:
TPMs are used to formulate an informative prior for the respective protein isoform relative abundance.
We further identify isoforms where the relative abundance of proteins and transcripts significantly differ.
We use a two-layer latent variable approach to model two sources of uncertainty typical of MS data:
i) peptides may be erroneously detected (even when absent);
ii) many peptides are compatible with multiple protein isoforms.
In the first layer, we sample the presence/absence of each peptide based on its estimated probability 
of being mistakenly detected, also known as PEP.
In the second layer, for peptides that were estimated as being present, 
we allocate their abundance across the protein isoforms they map to.
These two steps allow us to recover the presence and abundance of each protein isoform.

## Bioconductor installation
*SIMBA* is available on [Bioconductor](https://bioconductor.org/packages/SIMBA) and can be installed with the command:
```{r Bioconductor_installation, eval=FALSE}
if (!requireNamespace("BiocManager", quietly=TRUE))
  install.packages("BiocManager")
BiocManager::install("SIMBA")
```

To access the R code used in the vignettes, type:
```{r vignettes, eval=FALSE} 
browseVignettes("SIMBA")
```

# Questions, issues and citation
Questions relative to *SIMBA* should be reported as a new issue at *[BugReports](https://github.com/SimoneTiberi/SIMBA/issues)*.

To cite *SIMBA*, type:
```{r citation} 
citation("SIMBA")
```

# Load the package
Load *SIMBA*.
```{r load, message=FALSE}
library(SIMBA)
```

# Input data
To start using *SIMBA*, we need to load and process the input data using the `load_data` function. We can use *MetaMorpheus* (MM) [@MetaMorpheus], or *OpenMS* Toolkit [@OpenMS] to create the data that need to be inputted. Other tools can be used as well, as long as the input files 
follow the structure mentioned in the [From user data](#from-user-data) Section.

In this tutorial, we use a small dataset created by *MetaMorpheus*. The code to create it can be found here: [link a inst/script, come?]. We start by setting the directory of the data (internal in the package):
```{r specify extdata path}
data_dir = system.file("extdata", package = "SIMBA")
```

## From *MetaMorpheus* Tool
We create a string with the path to the AllPeptides.psmtsv file returned by *MetaMorpheus*:
```{r set path MM psm}
path_to_peptides_psm = paste0(data_dir, "/AllPeptides.psmtsv")
```

### Peptide-Spectrum Match (PSM) counts
The AllPeptides.psmtsv file contains all the information required to run *SIMBA* with PSM counts. To load the file run:
```{r load psm}
data_loaded = load_data(path_to_peptides_psm = path_to_peptides_psm)
```

### Intensities
If we want to run the algorithm with peptide intensities, in addition to "AllPeptides.psmtsv", we need to load a second file generated by MM: "AllQuantifiedPeptides.tsv". Next, we need to make sure that the argument `abundance_type` is set to "intensities". If not, the \code{load_data} function will ignore the "AllQuantifiedPeptides.tsv" file.
```{r set path MM intensities}
path_to_peptides_intensities = paste0(data_dir, "/AllQuantifiedPeptides.tsv")
data_loaded = load_data(path_to_peptides_psm = path_to_peptides_psm,
                        path_to_peptides_intensities = path_to_peptides_intensities,
                        abundance_type = "intensities")
```

## From *Percolator* (*OpenMS* Toolkit)
*SIMBA* is also compatible with the PSM file from *Percolator* [@Percolator]. Clicking on the following [link](https://github.com/SimoneTiberi/SIMBA/tree/main#readme) will lead you to a pipeline that uses *OpenMS* tools to generate an idXML file containing PSM data. Once the file is created, we just need to pass the file path to the \code{load_data} function and set `input_type` as "openMS".
```{r set path OpenMS, eval = FALSE}
data_loaded = load_data(path_to_peptides_psm = "/path/to/file.idXML",
                        input_type = "openMS")
```
Please note that when using data generated by *Percolator*, the algorithm can only process PSM counts and not intensities. Additionally, the `FDR_thd` option is not considered (see [FDR threshold](#fdr_threshold) Section). FDR filtering should be performed during the data generation (see link pipeline sopracitata).

## From user data
We can also input data coming from any bioinformatics tool. To this aim, the data must be organized in a tsv file where each raw corresponds to an identified peptide with four fields:

* 'Y': a numeric variable indicating the peptide abundance;
* 'EC': Equivalent Classes, a character string indicating the isoform(s) name the peptide maps to. If the peptide maps to multiple protein isoforms, the names must be separated with "|", i.e. "name_isoform_1|name_isoform_2";
* 'PEP': (optional) a numeric variable indicating the Peptide Error Probability;
* 'sequence': (required with PEP) a character string indicating the peptide name/id/amino acids sequence.

Please remember that when using user data, the options `abundance_type`, `FDR_thd`, and `path_to_peptides_intensities` are not considered.

To load the tsv file with user data, we just need to pass the file path and set `input_type` as "other".
```{r set path user}
# NOT RUN
#data_loaded = load_data(path_to_peptides_psm = "/path/to/user_data.tsv",
#                        input_type = "other")
```

## mRNA data integration
When available, the abundances (TPMs) of transcript isoforms can be incorporated in the model to enhance protein isoforms inference. To load TPMs data, we just need to specify the path to the TPMs file. The format file must be a tsv with two fields for each isoform, i.e.:

* 'isoname': a character string indicating the isoform name;
* 'tpm': a numeric variable indicating the transcripts per million.

```{r set path mRNA}
tpm_path = paste0(data_dir, "/jurkat_isoform_kallisto.tsv")
data_loaded = load_data(path_to_peptides_psm = path_to_peptides_psm,
                        path_to_tpm = tpm_path)
```

## FDR threshold
For data generated by MM, we can set the FDR threshold to filter out unreliable peptides. By default the `FDR_thd` option is equal to 0.01.

## PEP option
If the Peptide Error Probability is provided, we can enable the `PEP` option to add a layer to the Bayesian variable latent model. With this additional layer the algorithm will sample the presence/absence of each peptide based on its PEP.
```{r with PEP}
# NOT RUN
# data_loaded_pep = load_data(path_to_peptides_psm = path_to_peptides_psm,
#                             PEP = TRUE)
```

# Run *SIMBA* algorithm
Once we have loaded the data, we can run the algorithm using the `inference` function:
```{r inference}
# NOT RUN
# results = inference(data_loaded)
```

## Gene Normalization
In order to output protein isoforms results normalized by gene, we require a csv file containing two columns denoting the isoform name and the gene name. 
```{r default inference}
path_to_map_iso_gene = paste0(data_dir, "/map_iso_gene.csv")
t_start = Sys.time()
results = inference(data_loaded, map_iso_gene = path_to_map_iso_gene)
t_end = Sys.time()
default_time = t_end - t_start
```

## Setting the prior
The transcriptomics data contribute to formulate an informative prior for the relative abundances of the protein isoforms. PIs relative abundances are sampled from a Dirichelet distribution with concentration parameters proportional to the protein absolute abundance and the transcript absolute abundance multiplied by a \beta coefficient. By default, \beta is equal to 10% of the overall protein abundance. A prior equal to zero is equivalent to run the model without transcriptomics data integration, while larger values force the inference process to ignore the information coming from proteomics data.
```{r no prior inference}
# NOT RUN
# results_no_prior = inference(data_loaded, prior = 0, map_iso_gene = path_to_map_iso_gene)
```

## Parallel computation
By default, the `inference` function execute the algorithm using only one core. To speed up the execution time, we can turn on parallel computation and increase the number of cores:
```{r no parallel inference}
t_start = Sys.time()
results_parallel = inference(data_loaded, parallel = TRUE, map_iso_gene = path_to_map_iso_gene, n_cores = 8)
t_end = Sys.time()
parallel_time = t_end - t_start

# Single core VS parallel computation (two cores):
parallel_time - default_time
```
Sottolineare che il guadagno di tempo è trascurabile in quanto il dataset è piccolo?

# Plotting the results
Finally, *SIMBA* provides the `plot_relative_abundances` function to visualize differential relative abundances between transcriptomics and
proteomics isoforms within a specific gene:
```{r plotting results}
plot_relative_abundances(results, gene_id = "HLA")
```
By default `plot_relative_abundances` normalizes the relative abundances. To disable the normalization, we just need to set as FALSE the
`normalize_gene` argument.
```{r plotting results no normalization}
plot_relative_abundances(results, gene_id = "HLA", normalize_gene = F)
```
Please note that `plot_relative_abundances` properly works because, before running the `inference` function, we provided a csv file that maps all the protein isoforms to the corresponding gene.

# Session info
```{r sessionInfo}
sessionInfo()
```

# References